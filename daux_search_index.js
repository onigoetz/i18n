load_search_index({"pages":[{"title":"I18N","text":"I18n @onigoetz\/i18n A suite of packages to ease your translation needs. Packages @onigoetz\/messageformat a MessageFormat parsing and rendering library @onigoetz\/make-plural a lighter fork of make-plural meant for browser usage @onigoetz\/intl-formatters default formatters if you don\u2019t already have formatters for dates and numbers, uses the standard Intl API Features Small, Fast and no NPM dependencies TypeScript \u2764\ufe0f Fully tested Flexible; Use one package, or two, bring your own formatters, or use the embedded ones, use on Node.js, or in the browser. You choose ! ICU MessageFormat compatible CLDR compatible Example import { parse, createRenderer } from \"@onigoetz\/messageformat\"; import { dateFormatter, numberFormatter, pluralGenerator } from \"@onigoetz\/intl-formatters\"; \/\/ Parse the MessageFormat to a renderable format const parsed = parse(\"{test, plural, offset:3 one{one test} other {# test} }\"); \/\/ Create a localized renderer const render = createRenderer( \"en\", (locale: T, type) =&gt; pluralGenerator(locale, { type }), (locale: T, options, value: number) =&gt; numberFormatter(locale, options)(value), (locale: T, options, value: Date) =&gt; dateFormatter(locale, options)(value) ); render(parsed, { test: 4 }); \/\/ =&gt; \"one test\" render(parsed, { test: 7 }); \/\/ =&gt; \"4 test\" Who is the audience for this library ? This library is meant for applications starting with medium scale, where you might have multiple libraries and frameworks inside. Since these libraries don\u2019t make any assumption about your stack, you can integrate them in any kind of application. Most importantly, if you have an environment where pre-compiling translations isn\u2019t possible, for example because your translation build process is separate from your app build process or you have a modular application \/ microfrontend. This library is very interesting as a lightweight runtime because of its small footprint and performant parsing. Inspiration This suite of packages certainly wouldn\u2019t exist without the previous work in the field. This package forked make-plural at version 4 to make it smaller. Took inspiration for the MessageFormat parser from @ffz\/icu-msgparser for its small size and @phensley\/messageformat for its parsing speed.","tags":"","url":"index.html"},{"title":"intl-formatters","text":"This package provides simple implementations for Messageformat using the Intl API. Features Numbers and currencies: https:\/\/developer.mozilla.org\/fr\/docs\/Web\/JavaScript\/Reference\/Objets_globaux\/Intl\/NumberFormat Dates: https:\/\/developer.mozilla.org\/fr\/docs\/Web\/JavaScript\/Reference\/Objets_globaux\/Intl\/DateTimeFormat Relative Time: https:\/\/developer.mozilla.org\/fr\/docs\/Web\/JavaScript\/Reference\/Objets_globaux\/Intl\/RelativeTimeFormat Plurals: https:\/\/developer.mozilla.org\/fr\/docs\/Web\/JavaScript\/Reference\/Objets_globaux\/Intl\/PluralRules How to use These formatters are best used in conjunction with @onigoetz\/messageformat. However they are fully Typed and you may use them for any other use. import { parse, createRenderer } from \"@onigoetz\/messageformat\"; import { dateFormatter, numberFormatter, pluralGenerator, } from \"@onigoetz\/intl-formatters\"; \/\/ Parse the MessageFormat to a renderable format const parsed = parse(\"{test, plural, offset:3 one{one test} other {# test} }\"); \/\/ Create a localized renderer const render = createRenderer( \"en\", (locale: T, type) =&gt; pluralGenerator(locale, { type }), (locale: T, options, value: number) =&gt; numberFormatter(locale, options)(value), (locale: T, options, value: Date) =&gt; dateFormatter(locale, options)(value) ); render(parsed, { test: 4 }); \/\/ =&gt; \"one test\" render(parsed, { test: 7 }); \/\/ =&gt; \"4 test\" For NodeJS If you do some generation using NodeJS and wish to use locales other than en. I strongly suggest you look at the following page : https:\/\/nodejs.org\/api\/intl.html#intl_providing_icu_data_at_runtime This page explains how to make sure you have all the right locales loaded to make your formatting. Browser Support Intl Base API (Dates, Numbers, Currencies, Relative Time) Plurals","tags":"","url":"Packages\/intl_formatters.html"},{"title":"make-plural","text":"This package is a fork of make-plural version 4. It provided a compiler for CLDR plurals, but it also contained a lot of methods to test them. I stripped the test methods and kept the conversion code to make it smaller. Usage import makePlural from \"@onigoetz\/make-plural\"; \/\/ Original CLDR data const pluralRules = { \"plurals-type-cardinal\": { en: { \"pluralRule-count-one\": \"i = 1 and v = 0 @integer 1\", \"pluralRule-count-other\": \" @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, \u2026 @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, \u2026\" } }, \"plurals-type-ordinal\": { en: { \"pluralRule-count-one\": \"n % 10 = 1 and n % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, \u2026\", \"pluralRule-count-two\": \"n % 10 = 2 and n % 100 != 12 @integer 2, 22, 32, 42, 52, 62, 72, 82, 102, 1002, \u2026\", \"pluralRule-count-few\": \"n % 10 = 3 and n % 100 != 13 @integer 3, 23, 33, 43, 53, 63, 73, 83, 103, 1003, \u2026\", \"pluralRule-count-other\": \" @integer 0, 4~18, 100, 1000, 10000, 100000, 1000000, \u2026\" } } }; const pluralGenerator = makePlural(pluralRules[\"plurals-type-ordinal\"][\"en\"]); console.log(pluralGenerator(3)) \/\/ =&gt; few Size optimization The original CLDR data is quite verbose and if you can preprocess it, a lot of data can be removed. You can remove anything after @decimal or @integer and the other rule, you can go from : { \"plurals-type-cardinal\": { \"en\": { \"pluralRule-count-one\": \"i = 1 and v = 0 @integer 1\", \"pluralRule-count-other\": \" @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, \u2026 @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, \u2026\" } }, \"plurals-type-ordinal\": { \"en\": { \"pluralRule-count-one\": \"n % 10 = 1 and n % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, \u2026\", \"pluralRule-count-two\": \"n % 10 = 2 and n % 100 != 12 @integer 2, 22, 32, 42, 52, 62, 72, 82, 102, 1002, \u2026\", \"pluralRule-count-few\": \"n % 10 = 3 and n % 100 != 13 @integer 3, 23, 33, 43, 53, 63, 73, 83, 103, 1003, \u2026\", \"pluralRule-count-other\": \" @integer 0, 4~18, 100, 1000, 10000, 100000, 1000000, \u2026\" } } } to : { \"plurals-type-cardinal\": { \"en\": { \"pluralRule-count-one\": \"i = 1 and v = 0\" } }, \"plurals-type-ordinal\": { \"en\": { \"pluralRule-count-one\": \"n % 10 = 1 and n % 100 != 11\", \"pluralRule-count-two\": \"n % 10 = 2 and n % 100 != 12\", \"pluralRule-count-few\": \"n % 10 = 3 and n % 100 != 13\" } } } Efficient pluralGenerator If you need to create many plural generators, parsing the CLDR data many times isn\u2019t efficient. You can create a small factory function like this: const pluralRules = {}; \/\/ CLDR data const pluralMemory = {}; function pluralGenerator(locale, type) { const key = `${locale}-${type}`; if (!pluralMemory.hasOwnProperty(key)) { pluralMemory[key] = makePlural( pluralRules[`plurals-type-${type}`][locale] ); } return pluralMemory[key]; }","tags":"","url":"Packages\/make_plural.html"},{"title":"messageformat","text":"","tags":"","url":"Packages\/messageformat.html"},{"title":"Specification","text":"This is an overview of the specification of MessageFormat. It seems that each language has a different specification for how MessageFormat needs to be parsed and rendered. This page will try to make a recap of what I understand and how that translate in practical usage. The rest of this page is in progress message = messageText (argument messageText)* argument = noneArg | simpleArg | complexArg complexArg = choiceArg | pluralArg | selectArg | selectordinalArg noneArg = '{' argNameOrNumber '}' simpleArg = '{' argNameOrNumber ',' argType [',' argStyle] '}' choiceArg = '{' argNameOrNumber ',' &quot;choice&quot; ',' choiceStyle '}' pluralArg = '{' argNameOrNumber ',' &quot;plural&quot; ',' pluralStyle '}' selectArg = '{' argNameOrNumber ',' &quot;select&quot; ',' selectStyle '}' selectordinalArg = '{' argNameOrNumber ',' &quot;selectordinal&quot; ',' pluralStyle '}' choiceStyle: see ChoiceFormat pluralStyle: see PluralFormat selectStyle: see SelectFormat argNameOrNumber = argName | argNumber argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+ argNumber = '0' | ('1'..'9' ('0'..'9')*) argType = &quot;number&quot; | &quot;date&quot; | &quot;time&quot; | &quot;spellout&quot; | &quot;ordinal&quot; | &quot;duration&quot; argStyle = &quot;short&quot; | &quot;medium&quot; | &quot;long&quot; | &quot;full&quot; | &quot;integer&quot; | &quot;currency&quot; | &quot;percent&quot; | argStyleText | &quot;::&quot; argSkeletonText messageText can contain quoted literal strings including syntax characters. A quoted literal string begins with an ASCII apostrophe and a syntax character (usually a {curly brace}) and continues until the next single apostrophe. A double ASCII apostrohpe inside or outside of a quoted string represents one literal apostrophe. Quotable syntax characters are the {curly braces} in all messageText parts, plus the '#' sign in a messageText immediately inside a pluralStyle, and the '|' symbol in a messageText immediately inside a choiceStyle. See also MessagePattern.ApostropheMode In argStyleText, every single ASCII apostrophe begins and ends quoted literal text, and unquoted {curly braces} must occur in matched pairs. https:\/\/unicode-org.github.io\/icu-docs\/apidoc\/released\/icu4j\/com\/ibm\/icu\/text\/MessageFormat.html https:\/\/github.com\/unicode-org\/icu\/blob\/2666d18e544271d0f756bf20ee251c2cb699e269\/icu4j\/main\/classes\/core\/src\/com\/ibm\/icu\/text\/MessagePattern.java https:\/\/github.com\/unicode-org\/icu\/blob\/2666d18e544271d0f756bf20ee251c2cb699e269\/icu4j\/main\/classes\/core\/src\/com\/ibm\/icu\/impl\/PatternProps.java","tags":"","url":"Specification.html"},{"title":"Benchmark","text":"","tags":"","url":"Benchmark.html"}]});